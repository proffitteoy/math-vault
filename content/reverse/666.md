### 步骤
查壳：无壳，c语言

IDA反汇编给出的结果：
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char s[240]; 
  char v5[240];
  
  memset(s, 0, 0x1EuLL);
  printf("Please Input Key: ");
  __isoc99_scanf("%s", v5);
  encode(v5, s);
  if ( strlen(v5) == key )
  {
    if ( !strcmp(s, enflag) )
      puts("You are Right");
    else
      puts("flag{This_1s_f4cker_flag}");
  }
  return 0;
}
```

有三个关键：两个参数key，enflag和一个关键函数encode

encode的反汇编结果如下：
```c
int __fastcall encode(const char *a1, __int64 a2)
{
  _BYTE v3[104]; // [rsp+10h] [rbp-70h]
  int v4; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  i = 0;
  v4 = 0;
  if ( strlen(a1) != key )
    return puts("Your Length is Wrong");
  for ( i = 0; i < key; i += 3 )
  {
    v3[i + 64] = key ^ (a1[i] + 6);
    v3[i + 33] = (a1[i + 1] - 6) ^ key;
    v3[i + 2] = a1[i + 2] ^ 6 ^ key;
    *(_BYTE *)(a2 + i) = v3[i + 64];
    *(_BYTE *)(a2 + i + 1LL) = v3[i + 33];
    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];
  }
  return a2;
}
```
关键是
```c
    v3[i + 64] = key ^ (a1[i] + 6);
    v3[i + 33] = (a1[i + 1] - 6) ^ key;
    v3[i + 2] = a1[i + 2] ^ 6 ^ key;
```
这是一个累次加密过程

我们可以先写脚本:
```python
key = 
enflag = 
res = ""
for i in range(0, key, 3):
    c1 = (ord(enflag[i])   ^ key) - 6
    c2 = (ord(enflag[i+1]) ^ key) + 6
    c3 =  ord(enflag[i+2]) ^ 6 ^ key
    res += chr(c1) + chr(c2) + chr(c3)
print(res)
```

然后再回去找key和enflag

如果不知道变量在哪需要寻找在实战中是很困难的事情，不过这题中按G直接输入就能定位到
```
.data:0000000000004060 enflag          db 'izwhroz""w"v.K".Ni',0
.data:0000000000004060                                         ; DATA XREF: main+8F↑o
.data:0000000000004073                 align 20h
.data:0000000000004080                 public key
.data:0000000000004080 key             dd 12h                  ; DATA XREF: encode+2D↑r
```
其中12h换算成10进制是18

那么就有
```
key = 18
enflag = 'izwhroz""w"v.K".Ni'
```

代入脚本中本题结束。